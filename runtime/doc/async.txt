async.txt*     For Vim version 7.3.  Last change: 2010


Async communication                                  *async-communication*

1. Introduction				|async-communication-intro|

{Vi has None of this}
{only available when compiled with the |+async| feature}

==============================================================================
1. Introduction						*print-intro*

TODO:
  - fix gui and non gui version (by introducing mzscheme like timers)
  - enhance this help


Yes - Vim is only an editor. Yet this feature has been missing for too long
IMHO.

This short help text tries to document the --enable-async feature letting Vim
talk to processes in a non blocking interactive way. Thus you can run
interpreters, caching compilers (fcsh), or web servers within vim easily
appending their output to buffers.


:echo has('async') should be 1

this feature provides the following vim functions:

async_exec({ctx})   -- starts an asynchronous process


  context keys which will be used:
  ================================
    - cmd: the command to be executed. 

    /* idea (which I removed) because split() runs reasonable fast:
      - aslines (optional): if set a list of lines will be passed to the
                  functions receiving stdout/ err
                  You should not change this setting
    */

    - receive({data}, {fd}) (optional):
                                function called to pass data obtained
                                from the async process to the vim.  The
                                caller to async_exec can set this
                                method to receive data via async
                                allbacks.  If this function is not
                                defined the caller will have to poll
                                async_read in order to get data from the
                                process.

                                If 'aslines' attribute is set, thien the
                                {data} argument will be a list of lines,
                                otherwise it will contain a string with
                                all the data.

                                The {fd} argument identifies the source
                                of the data:
                                   1 - standard output
                                   2 - standard error

                                NOTE: current implementation merges
                                stderr into stdout.

    - started()    (optional) : called when process was started successfully
                                Now self.pid should contain the process id

    - terminated() (optional) : called when the process terminated (or when it was killed)
                                Now self.status should contain the exit status

  context keys which will be assigned:
  ====================================
    - pid    : the process pid
    - status : the process exit status.

  Note: You must not change pid yourself

async_kill({ctx})                -- kills an asynchronous process
async_list()                     -- returns list of processes
async_write({ctx}, {string})     -- pass string to stdin of context

TODO:
async_read_until({ctx}, {string} -- read bytes from stdout until one of the chars contained in string is found
                                 -- this way you can read lines etc easily.
                                    Don't know yet how useful it is. This way
                                    you can implement "blocking" read features
                                    if you have to.
                                    Example use case would be completion.
                                    Another way would be returning no
                                    completions restarting completion task if
                                    cursor didn't move and the completion
                                    results are received by the specified
                                    receive function

When a process dies it will be removed from the list.
So keep your own references if you have to.

VIML CODE EXAMPLE: >
  fun! s:Add(s)
    let l = [{'text': string(a:s)}]
    call setqflist(l, 'a')
  endf

  " ctx 1
  let ctx = { 'cmd' : 'nr=1; while read f; do nr=`expr $nr + 1`; sleep 1; echo $nr $f - pong; if [ $nr == 5 ]; then break; fi; done; exit 12' }
  fun ctx.receive(text, type)
    call s:Add(string(a:text))
    call async_write(self, "ping\n")
  endf

  fun ctx.started()
    call s:Add("ctx1: process started. pid:  ". self.pid)
  endf

  fun ctx.terminated()
    call s:Add("ctx1: process died. status (should be 12): ". self.status)
  endf

  call async_exec(ctx)
  call async_write(ctx, "ping\n")


  " ctx2 2
  let ctx2 = { 'cmd' : 'find / | while read f; do echo $f; sleep 1; done' }

  fun ctx2.receive(text, type)
    call s:Add('ctx22: '.string(a:text))
  endf

  fun ctx2.started()
    call s:Add("ctx22: process started. pid:  ". self.pid)
  endf

  fun ctx2.terminated()
    call s:Add("ctx22: process died. status:  ". self.status)
  endf
  call async_exec(ctx2)


random notes:
- writing to a process is a blocking operation. Ussually only little data is
  written which should fit into the os pipe buffer.

  Of course a non blocking version could be implemented (eg vim buffering all
  the data you want to write). I don't see any value doing so.

TODO:
- have async_exec() fill in kill/read/write handlers so it's possible to:
     ctx = { ... }
     call async_exec(ctx)
     call ctx.write('something')
     let txt = ctx.read()
     call ctx.kill()

